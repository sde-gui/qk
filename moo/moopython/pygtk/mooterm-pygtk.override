/* -%- lang: C; indent-width: 4; use-tabs: no; strip: yes -%- */
%%
headers
#include <Python.h>
#define NO_IMPORT_PYGOBJECT
#define NO_IMPORT_PYGTK
#include <pygobject.h>
#include <pygtk/pygtk.h>
#include <moo.h>
#include "moopython/moopython-utils.h"
#include "moopython/pygtk/moo-pygtk.h"


static GdkAtom
atom_from_pyobject(PyObject *object)
{
    if (object == NULL)
        return NULL;
    if (PyString_Check(object))
        return gdk_atom_intern(PyString_AsString(object), FALSE);
    if (PyGdkAtom_Check(object))
        return PyGdkAtom_Get(object);
    PyErr_SetString(PyExc_TypeError, "unable to convert argument to GdkAtom");
    return NULL;
}


%%
modulename moo.term
%%
import gtk.Widget as PyGtkWidget_Type
import gtk.Adjustment as PyGtkAdjustment_Type
import gobject.GObject as PyGObject_Type
%%
ignore-glob
  *_get_type
%%
override moo_term_new kwargs
static int
_wrap_moo_term_new (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, ":Term", kwlist))
        return -1;

    self->obj = g_object_new (MOO_TYPE_TERM, NULL);
    pygobject_register_wrapper ((PyObject*)self);

    return 0;
}
%%
override moo_term_copy_clipboard kwargs
static PyObject *
_wrap_moo_term_copy_clipboard (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "selection", NULL };
    PyObject *py_selection = NULL;
    GdkAtom selection;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:MooTerm.copy_clipboard", kwlist, &py_selection))
        return NULL;
    selection = atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;
    moo_term_copy_clipboard(MOO_TERM(self->obj), selection);
    return_None;
}
%%
override moo_term_paste_clipboard kwargs
static PyObject *
_wrap_moo_term_paste_clipboard(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "selection", NULL };
    PyObject *py_selection = NULL;
    GdkAtom selection;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:MooTerm.paste_clipboard", kwlist, &py_selection))
        return NULL;
    selection = atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;
    moo_term_paste_clipboard(MOO_TERM(self->obj), selection);
    return_None;
}
%%
override moo_term_get_iter_at_line varargs
static PyObject *
_wrap_moo_term_get_iter_at_line (PyGObject *self, PyObject *args)
{
    int line;
    MooTermIter iter;

    if (!PyArg_ParseTuple (args, "i:MooTerm.get_iter_at_line", &line))
        return NULL;

    if (moo_term_get_iter_at_line (MOO_TERM(self->obj), &iter, line))
        return pyg_boxed_new (MOO_TYPE_TERM_ITER, &iter, TRUE, TRUE);
    else
        return_None;
}
%%
override moo_term_get_iter_at_line_offset varargs
static PyObject *
_wrap_moo_term_get_iter_at_line_offset (PyGObject *self, PyObject *args)
{
    int line, offset;
    MooTermIter iter;

    if (!PyArg_ParseTuple (args, "ii:MooTerm.get_iter_at_line_offset", &line, &offset))
        return NULL;

    if (moo_term_get_iter_at_line_offset (MOO_TERM(self->obj), &iter, line, offset))
        return pyg_boxed_new (MOO_TYPE_TERM_ITER, &iter, TRUE, TRUE);
    else
        return_None;
}
%%
override moo_term_get_iter_at_cursor noargs
static PyObject *
_wrap_moo_term_get_iter_at_cursor (PyGObject *self)
{
    MooTermIter iter;

    moo_term_get_iter_at_cursor (MOO_TERM(self->obj), &iter);
    return pyg_boxed_new (MOO_TYPE_TERM_ITER, &iter, TRUE, TRUE);
}
%%
override moo_term_get_iter_at_location varargs
static PyObject *
_wrap_moo_term_get_iter_at_location (PyGObject *self, PyObject *args)
{
    int x, y;
    MooTermIter iter;

    if (!PyArg_ParseTuple (args, "ii:MooTerm.get_iter_at_location", &x, &y))
        return NULL;

    moo_term_get_iter_at_location (MOO_TERM(self->obj), &iter, x, y);
    return pyg_boxed_new (MOO_TYPE_TERM_ITER, &iter, TRUE, TRUE);
}
%%
override moo_term_get_iter_at_pos varargs
static PyObject *
_wrap_moo_term_get_iter_at_pos (PyGObject *self, PyObject *args)
{
    int x, y;
    MooTermIter iter;

    if (!PyArg_ParseTuple (args, "ii:MooTerm.get_iter_at_pos", &x, &y))
        return NULL;

    moo_term_get_iter_at_pos (MOO_TERM(self->obj), &iter, x, y);
    return pyg_boxed_new (MOO_TYPE_TERM_ITER, &iter, TRUE, TRUE);
}
%%
override moo_term_iter_copy noargs
static PyObject *
_wrap_moo_term_iter_copy (PyObject *self)
{
    MooTermIter *ret;

    ret = moo_term_iter_copy(pyg_boxed_get(self, MooTermIter));

    return pyg_boxed_new (MOO_TYPE_TERM_ITER, ret, FALSE, TRUE);
}
%%
override moo_term_window_to_buffer_coords varargs
static PyObject *
_wrap_moo_term_window_to_buffer_coords (PyGObject *self, PyObject *args)
{
    int x, y;
    int buf_x, buf_y;

    if (!PyArg_ParseTuple (args, "ii:MooTerm.window_to_buffer_coords", &x, &y))
        return NULL;

    moo_term_window_to_buffer_coords (MOO_TERM(self->obj), x, y, &buf_x, &buf_y);
    return Py_BuildValue("(ii)", buf_x, buf_y);
}
%%
override moo_term_feed varargs
static PyObject *
_wrap_moo_term_feed (PyGObject *self, PyObject *args)
{
    char *string;
    int len;

    if (!PyArg_ParseTuple (args, "s#:MooTerm.feed", &string, &len))
        return NULL;

    moo_term_feed (MOO_TERM (self->obj), string, len);
    return_None;
}
%%
override moo_term_feed_child varargs
static PyObject *
_wrap_moo_term_feed_child (PyGObject *self, PyObject *args)
{
    char *string;
    int len;

    if (!PyArg_ParseTuple (args, "s#:MooTerm.feed_child", &string, &len))
        return NULL;

    moo_term_feed_child (MOO_TERM (self->obj), string, len);
    return_None;
}
%%
override moo_term_get_screen_size noargs
static PyObject *
_wrap_moo_term_get_screen_size (PyGObject *self)
{
    guint columns, rows;
    moo_term_get_screen_size (MOO_TERM (self->obj), &columns, &rows);
    return Py_BuildValue ("(ii)", columns, rows);
}
%%
override moo_term_command_copy noargs
static PyObject *
_wrap_moo_term_command_copy (PyObject *self)
{
    MooTermCommand *ret;

    ret = moo_term_command_copy (pyg_boxed_get (self, MooTermCommand));

    return pyg_boxed_new (MOO_TYPE_TERM_COMMAND, ret, FALSE, TRUE);
}
%%
override moo_term_set_colors varargs
static PyObject *
_wrap_moo_term_set_colors (PyGObject *self, PyObject *args)
{
    GdkColor colors[4 + 2 * MOO_TERM_NUM_COLORS];
    guint i, n_colors;
    PyObject *py_colors;

    if (!PyArg_ParseTuple (args, "O:MooTerm.set_colors", &py_colors))
        return NULL;

    if (!PySequence_Check (py_colors))
        return_TypeError ("colors must be a list or tuple");

    n_colors = PySequence_Size (py_colors);

    if (n_colors != 2 + MOO_TERM_NUM_COLORS && n_colors != 4 + 2 * MOO_TERM_NUM_COLORS)
    {
        PyErr_Format (PyExc_ValueError, "number of colors must be %d or %d",
                      2 + MOO_TERM_NUM_COLORS, 4 + 2 * MOO_TERM_NUM_COLORS);
        return NULL;
    }

    for (i = 0; i < n_colors; ++i)
    {
        PyObject *c;

        c = PySequence_GetItem (py_colors, i);

        if (!pyg_boxed_check (c, GDK_TYPE_COLOR))
        {
            Py_XDECREF (c);
            PyErr_SetString (PyExc_ValueError, "colors must be a sequence of gdk.Color");
            return NULL;
        }

        colors[i] = *pyg_boxed_get (c, GdkColor);
        Py_XDECREF (c);
    }

    moo_term_set_colors (MOO_TERM (self->obj), colors, n_colors);
    return_None;
}
%%
override-slot MooTermTextAttr.tp_setattr
static int
_wrap_moo_term_text_attr_tp_setattr (PyGBoxed *self, char *attr, PyObject *value)
{
    if (!value)
        return_TypeErrorInt ("can't delete attributes");

    if (!strcmp (attr, "foreground") || !strcmp (attr, "background"))
    {
        int color;

        if (pyg_enum_get_value (MOO_TYPE_TERM_TEXT_COLOR, value, &color))
            return -1;

        if (!strcmp (attr, "foreground"))
            pyg_boxed_get (self, MooTermTextAttr)->foreground = color;
        else
            pyg_boxed_get (self, MooTermTextAttr)->background = color;

        return 0;
    }

    if (!strcmp (attr, "mask"))
    {
        int mask;

        if (pyg_enum_get_value (MOO_TYPE_TERM_TEXT_COLOR, value, &mask))
            return -1;

        pyg_boxed_get (self, MooTermTextAttr)->mask = mask;
        return 0;
    }

    PyErr_Format (PyExc_AttributeError, "no attribute '%s'", attr);
    return -1;
}
%%
override-slot MooTermIter.tp_setattr
static int
_wrap_moo_term_iter_tp_setattr (PyGBoxed *self, char *attr, PyObject *value)
{
    if (!value)
        return_TypeErrorInt ("can't delete attributes");

    if (!strcmp (attr, "row") || !strcmp (attr, "col"))
    {
        if (PyInt_Check (value))
        {
            int val = PyInt_AsLong(value);

            if (!strcmp(attr, "row"))
                pyg_boxed_get(self, MooTermIter)->row = val;
            else
                pyg_boxed_get(self, MooTermIter)->col = val;

            return 0;
        }

        PyErr_Format (PyExc_TypeError, "Iter.%s must be an integer", attr);
        return -1;
    }

    if (!strcmp (attr, "term") || !strcmp (attr, "line") || !strcmp (attr, "width"))
    {
        PyErr_Format (PyExc_AttributeError, "Iter.%s is not writable", attr);
        return -1;
    }

    PyErr_Format (PyExc_AttributeError, "no attribute '%s'", attr);
    return -1;
}
%%
override moo_term_get_selection_bounds noargs
static PyObject *
_wrap_moo_term_get_selection_bounds (PyGObject *self)
{
    MooTermIter start, end;

    if (moo_term_get_selection_bounds (MOO_TERM (self->obj), &start, &end))
    {
        PyObject *tuple = PyTuple_New (2);
        PyTuple_SET_ITEM (tuple, 0, pyg_boxed_new (MOO_TYPE_TERM_ITER, &start, TRUE, TRUE));
        PyTuple_SET_ITEM (tuple, 1, pyg_boxed_new (MOO_TYPE_TERM_ITER, &end, TRUE, TRUE));
        return tuple;
    }
    else
    {
        return_None;
    }
}
%%
override moo_term_command_new kwargs
static int
_wrap_moo_term_command_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cmd_line", "argv", "working_dir", "envp", NULL };
    char *cmd_line = NULL, **argv = NULL, *working_dir = NULL, **envp = NULL;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|zO&zO&:MooTermCommand.__init__",
                                      kwlist,
                                      &cmd_line,
                                      _moo_pyobject_to_strv, &argv,
                                      &working_dir,
                                      _moo_pyobject_to_strv, &envp))
        return -1;

    if (!argv || !cmd_line)
        return_ValueErrorInt ("Term.__init__: either argv or cmd_line must be given");

    if (argv && cmd_line)
        return_ValueErrorInt ("Term.__init__: only one of argv or cmd_line may be given");

    self->gtype = MOO_TYPE_TERM_COMMAND;
    self->free_on_dealloc = FALSE;

    if (argv)
        self->boxed = moo_term_command_new_argv (argv, working_dir, envp);
    else
        self->boxed = moo_term_command_new_command_line (cmd_line, working_dir, envp);

    if (!self->boxed)
        return_RuntimeErrorInt ("could not create MooTermCommand object");

    self->free_on_dealloc = TRUE;
    return 0;
}
