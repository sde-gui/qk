%%
headers
#include <Python.h>
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include "mooedit/mooeditor.h"
#include "mooedit/mootextsearch.h"
#include "mooedit/mootextbuffer.h"
#include "mooedit/mootextiter.h"
#include "mooedit/mooeditprefs.h"
#include "mooedit/moocmdview.h"
#include "mooedit/mooedit-actions.h"
#include "mooedit/mooplugin.h"
#include "moopython/moopython-utils.h"
#include "moopython/pygtk/moo-pygtk.h"


%%
modulename moo.edit
%%
import gtk.Widget as PyGtkWidget_Type
import gtk.TextView as PyGtkTextView_Type
import gtk.TextBuffer as PyGtkTextBuffer_Type
import gtk.TextTagTable as PyGtkTextTagTable_Type
import gtk.TextTag as PyGtkTextTag_Type
import gtk.Action as PyGtkAction_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gobject.GObject as PyGObject_Type
import moo.utils.Window as PyMooWindow_Type
import moo.utils.UIXML as PyMooUIXML_Type
%%
ignore-glob
  *_get_type
%%
override moo_python_plugin_register varargs
static PyObject *
_wrap_moo_python_plugin_register (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *plugin_type, *win_plugin_type = NULL, *doc_plugin_type = NULL;

    if (!PyArg_ParseTuple (args, (char*) "O|OO:plugin_register", &plugin_type,
                           &win_plugin_type, &doc_plugin_type))
        return NULL;

    if (!PyType_Check (plugin_type))
        return_TypeError ("argument must be a type");

    if (win_plugin_type && win_plugin_type != Py_None && !PyType_Check (win_plugin_type))
        return_TypeError ("argument must be a type");

    if (doc_plugin_type && doc_plugin_type != Py_None && !PyType_Check (doc_plugin_type))
        return_TypeError ("argument must be a type");

    if (win_plugin_type == Py_None)
        win_plugin_type = NULL;
    if (doc_plugin_type == Py_None)
        doc_plugin_type = NULL;

    return _moo_python_plugin_register (plugin_type, win_plugin_type, doc_plugin_type);
}
%%
override moo_plugin_list_methods noargs
static PyObject *
_wrap_moo_plugin_list_methods (PyGObject *self)
{
    PyObject *py_list;
    GSList *list;
    guint i;

    list = moo_plugin_list_methods (self->obj);

    if (!list)
        return PyTuple_New (0);

    i = 0;
    py_list = PyTuple_New (g_slist_length (list));

    while (list)
    {
        PyTuple_SET_ITEM (py_list, i, PyString_FromString (list->data));
        g_free (list->data);
        list = g_slist_delete_link (list, list);
        i++;
    }

    return py_list;
}
%%
override moo_list_plugins noargs
static PyObject *
_wrap_moo_list_plugins (G_GNUC_UNUSED PyGObject *self)
{
    PyObject *py_list;
    GSList *list;
    guint i;

    list = moo_list_plugins ();

    if (!list)
        return PyTuple_New (0);

    i = 0;
    py_list = PyTuple_New (g_slist_length (list));

    while (list)
    {
        PyTuple_SET_ITEM (py_list, i, pygobject_new (list->data));
        list = g_slist_delete_link (list, list);
        i++;
    }

    return py_list;
}
%%
override moo_plugin_lookup_method kwargs
static PyObject *
_wrap_moo_plugin_lookup_method (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { (char*) "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char*)"s:MooPlugin.lookup_method", kwlist, &name))
        return NULL;

    return PyBool_FromLong (moo_plugin_lookup_method (MOO_PLUGIN(self->obj), name) != 0);

}
%%
override moo_edit_window_list_docs noargs
static PyObject *
_wrap_moo_edit_window_list_docs (PyObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_edit_window_list_docs (MOO_EDIT_WINDOW (pygobject_get (self)));
    result = moo_object_slist_to_pyobject (list);

    g_slist_free (list);
    return result;
}
%%
override moo_editor_list_windows noargs
static PyObject *
_wrap_moo_editor_list_windows (PyObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_editor_list_windows (MOO_EDITOR (pygobject_get (self)));
    result = moo_object_slist_to_pyobject (list);

    g_slist_free (list);
    return result;
}
%%
override moo_editor_list_docs noargs
static PyObject *
_wrap_moo_editor_list_docs (PyObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_editor_list_docs (MOO_EDITOR (pygobject_get (self)));
    result = moo_object_slist_to_pyobject (list);

    g_slist_free (list);
    return result;
}
%%
override-attr MooLang.mime_types
static PyObject *
_wrap_moo_lang__get_mime_types (PyObject *self, G_GNUC_UNUSED void *closure)
{
    return moo_string_slist_to_pyobject (pyg_boxed_get (self, MooLang)->mime_types);
}
%%
override-attr MooLang.extensions
static PyObject *
_wrap_moo_lang__get_extensions (PyObject *self, G_GNUC_UNUSED void *closure)
{
    return moo_string_slist_to_pyobject (pyg_boxed_get (self, MooLang)->extensions);
}
%%
override moo_line_view_set_line_data varargs
static PyObject *
_wrap_moo_line_view_set_line_data (PyObject *self, PyObject *args)
{
    int line;
    PyObject *py_data;
    MooLineView *view;
    GValue data;

    if (!PyArg_ParseTuple (args, (char*) "iO:LineView.set_line_data", &line, &py_data))
        return NULL;

    view = MOO_LINE_VIEW (pygobject_get (self));

    data.g_type = 0;
    g_value_init (&data, MOO_TYPE_PY_OBJECT);

    if (pyg_value_from_pyobject (&data, py_data))
    {
        g_critical ("%s: oops", G_STRLOC);
        return NULL;
    }

    moo_line_view_set_line_data (view, line, &data);
    g_value_unset (&data);

    return_None;
}
%%
override moo_line_view_get_line_data varargs
static PyObject *
_wrap_moo_line_view_get_line_data (PyObject *self, PyObject *args)
{
    int line;
    MooLineView *view;
    GValue data;
    PyObject *obj;

    if (!PyArg_ParseTuple (args, (char*) "i:LineView.get_line_data", &line))
        return NULL;

    view = MOO_LINE_VIEW (pygobject_get (self));
    data.g_type = 0;

    if (!moo_line_view_get_line_data (view, line, &data))
        return_None;

    obj = pyg_value_as_pyobject (&data, FALSE);

    g_value_unset (&data);
    return obj;
}
%%
override moo_text_search_forward varargs
static PyObject *
_wrap_moo_text_search_forward (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *py_start, *py_flags, *py_end = Py_None;
    char *str;
    int flags;
    const GtkTextIter *start, *end = NULL;
    GtkTextIter match_start, match_end;

    if (!PyArg_ParseTuple(args, (char*) "OsO|O:search_forward", &py_start, &str, &py_flags, &py_end))
        return NULL;

    if (pyg_boxed_check (py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get (py_start, GtkTextIter);
    else
        return_TypeError ("start should be a GtkTextIter");

    if (pyg_flags_get_value (MOO_TYPE_TEXT_SEARCH_FLAGS, py_flags, &flags))
        return NULL;

    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else if (py_end != Py_None)
        return_TypeError ("end should be a GtkTextIter or None");

    if (moo_text_search_forward (start, str, flags, &match_start, &match_end, end))
    {
        PyObject *ret = PyTuple_New (2);
        PyTuple_SET_ITEM (ret, 0, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_start, TRUE, TRUE));
        PyTuple_SET_ITEM (ret, 1, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_end, TRUE, TRUE));
        return ret;
    }
    else
    {
        return_None;
    }
}
%%
override moo_text_search_backward varargs
static PyObject *
_wrap_moo_text_search_backward (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *py_start, *py_flags, *py_end = Py_None;
    char *str;
    int flags;
    const GtkTextIter *start, *end = NULL;
    GtkTextIter match_start, match_end;

    if (!PyArg_ParseTuple (args, (char*) "OsO|O:search_backward", &py_start, &str, &py_flags, &py_end))
        return NULL;

    if (pyg_boxed_check (py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get (py_start, GtkTextIter);
    else
        return_TypeError ("start should be a GtkTextIter");

    if (pyg_flags_get_value (MOO_TYPE_TEXT_SEARCH_FLAGS, py_flags, &flags))
        return NULL;

    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else if (py_end != Py_None)
        return_TypeError ("end should be a GtkTextIter or None");

    if (moo_text_search_backward (start, str, flags, &match_start, &match_end, end))
    {
        PyObject *ret = PyTuple_New (2);
        PyTuple_SET_ITEM (ret, 0, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_start, TRUE, TRUE));
        PyTuple_SET_ITEM (ret, 1, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_end, TRUE, TRUE));
        return ret;
    }
    else
    {
        return_None;
    }
}
%%
override moo_edit_class_add_action varargs
static PyObject *
_wrap_moo_edit_class_add_action (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *py_type, *py_id, *py_action_type;
    GType type, action_type;
    MooEditClass *klass;

    if (PyTuple_GET_SIZE (args) < 3)
        return_TypeError ("at least three arguments required");

    py_type = PyTuple_GET_ITEM (args, 0);
    py_id = PyTuple_GET_ITEM (args, 1);
    py_action_type = PyTuple_GET_ITEM (args, 2);

    if (!(type = pyg_type_from_object (py_type)))
        return NULL;

    if (!(action_type = pyg_type_from_object (py_action_type)))
        return NULL;

    if (!g_type_is_a (type, MOO_TYPE_EDIT))
        return_TypeError ("type must be derived from MooEdit");

    if (!g_type_is_a (action_type, MOO_TYPE_EDIT_ACTION))
        return_TypeError ("action_type must be derived from MooEditAction");

    if (!PyString_Check (py_id))
        return_TypeError ("id must be a string");

    klass = g_type_class_ref (type);

    moo_edit_class_new_action_type (klass, PyString_AS_STRING (py_id), action_type);

    g_type_class_unref (klass);
    return_None;
}
%%
override moo_edit_class_remove_action kwargs
static PyObject *
_wrap_moo_edit_class_remove_action (G_GNUC_UNUSED PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {(char*) "class", (char*) "id", NULL};
    PyObject *py_type;
    GType type;
    const char *action_id;
    MooEditClass *klass;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, (char*) "Os:window_class_remove_action", kwlist, &py_type, &action_id))
        return NULL;

    type = pyg_type_from_object (py_type);

    if (!type)
        return NULL;

    if (!g_type_is_a (type, MOO_TYPE_EDIT))
        return_TypeError ("type must be derived from MooEdit");

    klass = g_type_class_ref (type);
    moo_edit_class_remove_action (klass, action_id);
    g_type_class_unref (klass);

    return_None;
}
%%
override moo_edit_window_set_action_langs kwargs
static PyObject *
_wrap_moo_edit_window_set_action_langs (G_GNUC_UNUSED PyObject *self, PyObject *args, PyObject *kwargs)
{
    GSList *langs = NULL;
    PyObject *py_langs;
    const char *action_id, *action_prop;
    char *kwlist[] = {(char*) "action_id", (char*) "action_prop", (char*) "langs", NULL};

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, (char*) "ssO:window_set_action_langs",
                                      kwlist, &action_id, &action_prop, &py_langs))
        return NULL;

    if (py_langs != Py_None)
    {
        int n_items, i;
        char *lang_id;

        py_langs = PySequence_Fast (py_langs, "langs must be a sequence or None");

        if (!py_langs)
            return NULL;

        n_items = PySequence_Fast_GET_SIZE (py_langs);

        for (i = 0; i < n_items; ++i)
        {
            PyObject *lang = PySequence_Fast_GET_ITEM (py_langs, i);

            if (!PyString_Check (lang))
            {
                Py_DECREF (py_langs);
                g_slist_foreach (langs, (GFunc) g_free, NULL);
                g_slist_free (langs);
                return_TypeError ("langs must be a sequence of strings");
            }

            lang_id = moo_lang_id_from_name (PyString_AS_STRING (lang));
            langs = g_slist_prepend (langs, lang_id);
        }

        langs = g_slist_reverse (langs);
    }

    moo_edit_window_set_action_langs (action_id, action_prop, langs);

    Py_DECREF (py_langs);
    g_slist_foreach (langs, (GFunc) g_free, NULL);
    g_slist_free (langs);

    return_None;
}
%%
override moo_editor_create_instance noargs
static PyObject *
_wrap_moo_editor_create_instance (void)
{
    MooEditor *editor;
    PyObject *ret;

    editor = moo_editor_create_instance();
    ret = pygobject_new (G_OBJECT (editor));

    g_object_unref (editor);
    return ret;
}
%%
override moo_lang_mgr_get_available_langs noargs
static PyObject *
_wrap_moo_lang_mgr_get_available_langs (PyGObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_lang_mgr_get_available_langs (MOO_LANG_MGR (pygobject_get (self)));
    result = moo_boxed_slist_to_pyobject (list, MOO_TYPE_LANG);

    g_slist_free (list);
    return result;
}
%%
override moo_plugin_call_method varargs
static PyObject *
_wrap_moo_plugin_call_method (PyGObject *self, PyObject *args)
{
    const char *name;
    MooPluginMeth *meth;
    GValue *params = NULL;
    GValue retval;
    PyObject *ret = NULL;
    guint i;

    if (!args || !PyTuple_GET_SIZE (args))
        return_TypeError ("Plugin.call_method takes at least 1 argument");

    name = PyString_AsString (PyTuple_GET_ITEM (args, 0));

    if (!name)
        return NULL;

    meth = moo_plugin_lookup_method (self->obj, name);

    if (!meth)
    {
        PyErr_Format (PyExc_TypeError, "in Plugin.call_method: unknown method '%s'", name);
        return NULL;
    }

    if ((int) meth->n_params + 1 != PyTuple_GET_SIZE (args))
    {
        PyErr_Format (PyExc_TypeError, "in Plugin.call_method: method '%s' takes "
                      "exactly %d arguments (%d given)", name, meth->n_params,
                      PyTuple_GET_SIZE (args) - 1);
        return NULL;
    }

    if (meth->return_type != G_TYPE_NONE)
    {
        retval.g_type = 0;
        g_value_init (&retval, meth->return_type);
    }

    params = g_new0 (GValue, meth->n_params + 1);
    g_value_init (params, G_OBJECT_TYPE (self->obj));
    g_value_set_object (params, self->obj);

    for (i = 0; i < meth->n_params; ++i)
    {
        g_value_init (&params[i+1], meth->param_types[i]);

        if (pyg_value_from_pyobject (&params[i+1], PyTuple_GET_ITEM (args, i+1)))
        {
            PyObject *ps = PyObject_Str (PyTuple_GET_ITEM (args, i+1));
            char *s = PyString_AsString (ps);
            PyErr_Format(PyExc_TypeError, "could not convert object '%s' to type '%s'",
                         s ? s : "(unknown)", g_type_name (meth->param_types[i]));
            Py_XDECREF (ps);
            goto out;
        }
    }

    moo_plugin_call_methodv (params, name, &retval);

    if (meth->return_type != G_TYPE_NONE)
    {
        ret = pyg_value_as_pyobject (&retval, TRUE);
    }
    else
    {
        ret = Py_None;
        Py_INCREF (ret);
    }

out:
    if (meth->return_type != G_TYPE_NONE)
        g_value_unset (&retval);
    for (i = 0; i < meth->n_params + 1; ++i)
        if (G_IS_VALUE (&params[i]))
            g_value_unset (&params[i]);
    g_free (params);

    return ret;
}
