%%
headers
#include <Python.h>
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include "mooedit/mooeditor.h"
#include "mooedit/mootextsearch.h"
#include "mooedit/mootextbuffer.h"
#include "mooedit/mootextiter.h"
#include "mooedit/mooeditprefs.h"
#include "mooedit/moocmdview.h"
#include "mooedit/mooedit-actions.h"
#include "mooedit/mooplugin.h"
#include "mooedit/moocommand.h"
#include "moopython/moopython-utils.h"
#include "moopython/pygtk/moo-pygtk.h"


%%
modulename moo.edit
%%
import gtk.Widget as PyGtkWidget_Type
import gtk.Window as PyGtkWindow_Type
import gtk.TextView as PyGtkTextView_Type
import gtk.TextBuffer as PyGtkTextBuffer_Type
import gtk.TextTagTable as PyGtkTextTagTable_Type
import gtk.TextTag as PyGtkTextTag_Type
import gtk.Action as PyGtkAction_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gobject.GObject as PyGObject_Type
import moo.utils.Window as PyMooWindow_Type
import moo.utils.UIXML as PyMooUIXML_Type
%%
ignore-glob
  *_get_type
%%
override moo_python_plugin_register varargs
static PyObject *
_wrap_moo_python_plugin_register (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *plugin_type, *win_plugin_type = NULL, *doc_plugin_type = NULL;

    if (!PyArg_ParseTuple (args, (char*) "O|OO:plugin_register", &plugin_type,
                           &win_plugin_type, &doc_plugin_type))
        return NULL;

    if (!PyType_Check (plugin_type))
        return_TypeError ("argument must be a type");

    if (win_plugin_type && win_plugin_type != Py_None && !PyType_Check (win_plugin_type))
        return_TypeError ("argument must be a type");

    if (doc_plugin_type && doc_plugin_type != Py_None && !PyType_Check (doc_plugin_type))
        return_TypeError ("argument must be a type");

    if (win_plugin_type == Py_None)
        win_plugin_type = NULL;
    if (doc_plugin_type == Py_None)
        doc_plugin_type = NULL;

    return _moo_python_plugin_register (plugin_type, win_plugin_type, doc_plugin_type);
}
%%
override moo_plugin_list_methods noargs
static PyObject *
_wrap_moo_plugin_list_methods (PyGObject *self)
{
    PyObject *py_list;
    GSList *list;
    guint i;

    list = moo_plugin_list_methods (self->obj);

    if (!list)
        return PyTuple_New (0);

    i = 0;
    py_list = PyTuple_New (g_slist_length (list));

    while (list)
    {
        PyTuple_SET_ITEM (py_list, i, PyString_FromString (list->data));
        g_free (list->data);
        list = g_slist_delete_link (list, list);
        i++;
    }

    return py_list;
}
%%
override moo_list_plugins noargs
static PyObject *
_wrap_moo_list_plugins (G_GNUC_UNUSED PyGObject *self)
{
    PyObject *py_list;
    GSList *list;
    guint i;

    list = moo_list_plugins ();

    if (!list)
        return PyTuple_New (0);

    i = 0;
    py_list = PyTuple_New (g_slist_length (list));

    while (list)
    {
        PyTuple_SET_ITEM (py_list, i, pygobject_new (list->data));
        list = g_slist_delete_link (list, list);
        i++;
    }

    return py_list;
}
%%
override moo_plugin_lookup_method kwargs
static PyObject *
_wrap_moo_plugin_lookup_method (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { (char*) "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char*)"s:MooPlugin.lookup_method", kwlist, &name))
        return NULL;

    return PyBool_FromLong (moo_plugin_lookup_method (MOO_PLUGIN(self->obj), name) != 0);

}
%%
override moo_edit_window_list_docs noargs
static PyObject *
_wrap_moo_edit_window_list_docs (PyObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_edit_window_list_docs (MOO_EDIT_WINDOW (pygobject_get (self)));
    result = moo_object_slist_to_pyobject (list);

    g_slist_free (list);
    return result;
}
%%
override moo_editor_list_windows noargs
static PyObject *
_wrap_moo_editor_list_windows (PyObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_editor_list_windows (MOO_EDITOR (pygobject_get (self)));
    result = moo_object_slist_to_pyobject (list);

    g_slist_free (list);
    return result;
}
%%
override moo_editor_list_docs noargs
static PyObject *
_wrap_moo_editor_list_docs (PyObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_editor_list_docs (MOO_EDITOR (pygobject_get (self)));
    result = moo_object_slist_to_pyobject (list);

    g_slist_free (list);
    return result;
}
%%
override-attr MooLang.mime_types
static PyObject *
_wrap_moo_lang__get_mime_types (PyObject *self, G_GNUC_UNUSED void *closure)
{
    return moo_string_slist_to_pyobject (pyg_boxed_get (self, MooLang)->mime_types);
}
%%
override-attr MooLang.extensions
static PyObject *
_wrap_moo_lang__get_extensions (PyObject *self, G_GNUC_UNUSED void *closure)
{
    return moo_string_slist_to_pyobject (pyg_boxed_get (self, MooLang)->extensions);
}
%%
override moo_line_view_set_line_data varargs
static PyObject *
_wrap_moo_line_view_set_line_data (PyObject *self, PyObject *args)
{
    int line;
    PyObject *py_data;
    MooLineView *view;
    GValue data;

    if (!PyArg_ParseTuple (args, (char*) "iO:LineView.set_line_data", &line, &py_data))
        return NULL;

    view = MOO_LINE_VIEW (pygobject_get (self));

    data.g_type = 0;
    g_value_init (&data, MOO_TYPE_PY_OBJECT);

    if (pyg_value_from_pyobject (&data, py_data))
    {
        g_critical ("%s: oops", G_STRLOC);
        return NULL;
    }

    moo_line_view_set_line_data (view, line, &data);
    g_value_unset (&data);

    return_None;
}
%%
override moo_line_view_get_line_data varargs
static PyObject *
_wrap_moo_line_view_get_line_data (PyObject *self, PyObject *args)
{
    int line;
    MooLineView *view;
    GValue data;
    PyObject *obj;

    if (!PyArg_ParseTuple (args, (char*) "i:LineView.get_line_data", &line))
        return NULL;

    view = MOO_LINE_VIEW (pygobject_get (self));
    data.g_type = 0;

    if (!moo_line_view_get_line_data (view, line, &data))
        return_None;

    obj = pyg_value_as_pyobject (&data, FALSE);

    g_value_unset (&data);
    return obj;
}
%%
override moo_text_search_forward varargs
static PyObject *
_wrap_moo_text_search_forward (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *py_start, *py_flags, *py_end = Py_None;
    char *str;
    int flags;
    const GtkTextIter *start, *end = NULL;
    GtkTextIter match_start, match_end;

    if (!PyArg_ParseTuple(args, (char*) "OsO|O:search_forward", &py_start, &str, &py_flags, &py_end))
        return NULL;

    if (pyg_boxed_check (py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get (py_start, GtkTextIter);
    else
        return_TypeError ("start should be a GtkTextIter");

    if (pyg_flags_get_value (MOO_TYPE_TEXT_SEARCH_FLAGS, py_flags, &flags))
        return NULL;

    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else if (py_end != Py_None)
        return_TypeError ("end should be a GtkTextIter or None");

    if (moo_text_search_forward (start, str, flags, &match_start, &match_end, end))
    {
        PyObject *ret = PyTuple_New (2);
        PyTuple_SET_ITEM (ret, 0, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_start, TRUE, TRUE));
        PyTuple_SET_ITEM (ret, 1, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_end, TRUE, TRUE));
        return ret;
    }
    else
    {
        return_None;
    }
}
%%
override moo_text_search_backward varargs
static PyObject *
_wrap_moo_text_search_backward (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *py_start, *py_flags, *py_end = Py_None;
    char *str;
    int flags;
    const GtkTextIter *start, *end = NULL;
    GtkTextIter match_start, match_end;

    if (!PyArg_ParseTuple (args, (char*) "OsO|O:search_backward", &py_start, &str, &py_flags, &py_end))
        return NULL;

    if (pyg_boxed_check (py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get (py_start, GtkTextIter);
    else
        return_TypeError ("start should be a GtkTextIter");

    if (pyg_flags_get_value (MOO_TYPE_TEXT_SEARCH_FLAGS, py_flags, &flags))
        return NULL;

    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else if (py_end != Py_None)
        return_TypeError ("end should be a GtkTextIter or None");

    if (moo_text_search_backward (start, str, flags, &match_start, &match_end, end))
    {
        PyObject *ret = PyTuple_New (2);
        PyTuple_SET_ITEM (ret, 0, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_start, TRUE, TRUE));
        PyTuple_SET_ITEM (ret, 1, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_end, TRUE, TRUE));
        return ret;
    }
    else
    {
        return_None;
    }
}
%%
override moo_edit_class_add_action varargs
static PyObject *
_wrap_moo_edit_class_add_action (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *py_type, *py_id, *py_action_type;
    GType type, action_type;
    MooEditClass *klass;

    if (PyTuple_GET_SIZE (args) < 3)
        return_TypeError ("at least three arguments required");

    py_type = PyTuple_GET_ITEM (args, 0);
    py_id = PyTuple_GET_ITEM (args, 1);
    py_action_type = PyTuple_GET_ITEM (args, 2);

    if (!(type = pyg_type_from_object (py_type)))
        return NULL;

    if (!(action_type = pyg_type_from_object (py_action_type)))
        return NULL;

    if (!g_type_is_a (type, MOO_TYPE_EDIT))
        return_TypeError ("type must be derived from MooEdit");

    if (!g_type_is_a (action_type, MOO_TYPE_EDIT_ACTION))
        return_TypeError ("action_type must be derived from MooEditAction");

    if (!PyString_Check (py_id))
        return_TypeError ("id must be a string");

    klass = g_type_class_ref (type);

    moo_edit_class_new_action_type (klass, PyString_AS_STRING (py_id), action_type);

    g_type_class_unref (klass);
    return_None;
}
%%
override moo_edit_class_remove_action kwargs
static PyObject *
_wrap_moo_edit_class_remove_action (G_GNUC_UNUSED PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {(char*) "class", (char*) "id", NULL};
    PyObject *py_type;
    GType type;
    const char *action_id;
    MooEditClass *klass;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, (char*) "Os:window_class_remove_action", kwlist, &py_type, &action_id))
        return NULL;

    type = pyg_type_from_object (py_type);

    if (!type)
        return NULL;

    if (!g_type_is_a (type, MOO_TYPE_EDIT))
        return_TypeError ("type must be derived from MooEdit");

    klass = g_type_class_ref (type);
    moo_edit_class_remove_action (klass, action_id);
    g_type_class_unref (klass);

    return_None;
}
%%
override moo_editor_create_instance noargs
static PyObject *
_wrap_moo_editor_create_instance (void)
{
    MooEditor *editor;
    PyObject *ret;

    editor = moo_editor_create_instance();
    ret = pygobject_new (G_OBJECT (editor));

    g_object_unref (editor);
    return ret;
}
%%
override moo_lang_mgr_get_available_langs noargs
static PyObject *
_wrap_moo_lang_mgr_get_available_langs (PyGObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_lang_mgr_get_available_langs (MOO_LANG_MGR (pygobject_get (self)));
    result = moo_boxed_slist_to_pyobject (list, MOO_TYPE_LANG);

    g_slist_free (list);
    return result;
}
%%
override moo_plugin_call_method varargs
static PyObject *
_wrap_moo_plugin_call_method (PyGObject *self, PyObject *args)
{
    const char *name;
    MooPluginMeth *meth;
    GValue *params = NULL;
    GValue retval;
    PyObject *ret = NULL;
    guint i;

    if (!args || !PyTuple_GET_SIZE (args))
        return_TypeError ("Plugin.call_method takes at least 1 argument");

    name = PyString_AsString (PyTuple_GET_ITEM (args, 0));

    if (!name)
        return NULL;

    meth = moo_plugin_lookup_method (self->obj, name);

    if (!meth)
    {
        PyErr_Format (PyExc_TypeError, "in Plugin.call_method: unknown method '%s'", name);
        return NULL;
    }

    if ((int) meth->n_params + 1 != PyTuple_GET_SIZE (args))
    {
        PyErr_Format (PyExc_TypeError, "in Plugin.call_method: method '%s' takes "
                      "exactly %d arguments (%d given)", name, meth->n_params,
                      PyTuple_GET_SIZE (args) - 1);
        return NULL;
    }

    if (meth->return_type != G_TYPE_NONE)
    {
        retval.g_type = 0;
        g_value_init (&retval, meth->return_type);
    }

    params = g_new0 (GValue, meth->n_params + 1);
    g_value_init (params, G_OBJECT_TYPE (self->obj));
    g_value_set_object (params, self->obj);

    for (i = 0; i < meth->n_params; ++i)
    {
        g_value_init (&params[i+1], meth->param_types[i]);

        if (pyg_value_from_pyobject (&params[i+1], PyTuple_GET_ITEM (args, i+1)))
        {
            PyObject *ps = PyObject_Str (PyTuple_GET_ITEM (args, i+1));
            char *s = PyString_AsString (ps);
            PyErr_Format(PyExc_TypeError, "could not convert object '%s' to type '%s'",
                         s ? s : "(unknown)", g_type_name (meth->param_types[i]));
            Py_XDECREF (ps);
            goto out;
        }
    }

    moo_plugin_call_methodv (params, name, &retval);

    if (meth->return_type != G_TYPE_NONE)
    {
        ret = pyg_value_as_pyobject (&retval, TRUE);
    }
    else
    {
        ret = Py_None;
        Py_INCREF (ret);
    }

out:
    if (meth->return_type != G_TYPE_NONE)
        g_value_unset (&retval);
    for (i = 0; i < meth->n_params + 1; ++i)
        if (G_IS_VALUE (&params[i]))
            g_value_unset (&params[i]);
    g_free (params);

    return ret;
}
%%
override moo_command_context_set kwargs
static PyObject *
_wrap_moo_command_context_set (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {(char*) "name", (char*) "value", NULL};
    char *name;
    PyObject *py_value;
    GValue value;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, (char*) "sO:MooCommandContext.set", kwlist,
                                      &name, &py_value))
        return NULL;

    if (py_value == Py_None)
        return_TypeError ("MooCommandContext.set: value may not be None");

    value.g_type = 0;
    moo_pyobject_to_gvalue (py_value, &value);

    moo_command_context_set (MOO_COMMAND_CONTEXT (self->obj), name, &value);

    g_value_unset (&value);
    return_None;
}
%%
override moo_command_context_get kwargs
static PyObject *
_wrap_moo_command_context_get (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {(char*) "name", NULL};
    char *name;
    PyObject *py_value;
    GValue value;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, (char*) "s:MooCommandContext.get",
                                      kwlist, &name))
        return NULL;

    value.g_type = 0;

    if (!moo_command_context_get (MOO_COMMAND_CONTEXT (self->obj), name, &value))
        return_None;

    py_value = moo_gvalue_to_pyobject (&value);
    g_assert (py_value || PyErr_Occurred ());

    g_value_unset (&value);
    return py_value;
}
%%
override moo_command_context_foreach varargs
static void
context_foreach_func (const char   *name,
                      const GValue *value,
                      gpointer      user_data)
{
    PyObject *py_value, *ret;

    struct {
        PyObject *func;
        PyObject *data;
        gboolean error;
    } *data = user_data;

    if (data->error)
        return;

    py_value = pyg_value_as_pyobject (value, TRUE);

    if (!py_value)
    {
        data->error = TRUE;
        return;
    }

    PyTuple_SetItem (data->data, 0, PyString_FromString (name));
    PyTuple_SetItem (data->data, 1, py_value);

    ret = PyObject_CallObject (data->func, data->data);

    if (ret != NULL)
        Py_DECREF (ret);
    else
        data->error = TRUE;
}

static PyObject *
_wrap_moo_command_context_foreach (PyGObject *self, PyObject *args)
{
    int len, i;
    PyObject *py_func, *py_data;
    struct {
        PyObject *func;
        PyObject *data;
        gboolean error;
    } data;

    len = PyTuple_GET_SIZE (args);

    if (len == 0)
        return_ValueError ("MooCommandContext.foreach: at least one argument is requred");

    py_func = PyTuple_GET_ITEM (args, 0);

    if (!PyCallable_Check (py_func))
        return_TypeError ("MooCommandContext.foreach: argument must be callable");

    py_data = PyTuple_New (len + 1);

    for (i = 1; i < len; ++i)
    {
        PyObject *item = PyTuple_GET_ITEM (args, i);
        Py_INCREF (item);
        PyTuple_SetItem (py_data, i + 1, item);
    }

    data.func = py_func;
    data.data = py_data;
    data.error = FALSE;

    moo_command_context_foreach (MOO_COMMAND_CONTEXT (self->obj),
                                 context_foreach_func,
                                 &data);

    Py_DECREF (py_data);

    if (data.error)
        return NULL;

    return_None;
}
%%
override moo_command_type_register kwargs

typedef struct {
    PyObject *factory_func;
    PyObject *create_widget_func;
    PyObject *load_data_func;
    PyObject *save_data_func;
    PyObject *data;
} CommandTypeData;

static MooCommand *
command_factory_func (MooCommandData *data,
                      const char     *flags,
                      gpointer        user_data)
{
    MooCommand *cmd;
    PyObject *py_cmd, *py_data, *py_flags;
    CommandTypeData *type_data = user_data;

    py_data = pyg_boxed_new (MOO_TYPE_COMMAND_DATA, data, TRUE, TRUE);
    py_flags = PyString_FromString (flags);

    if (type_data->data)
        py_cmd = PyObject_CallFunction (type_data->factory_func, (char*) "OOO",
                                        py_data, py_flags, type_data->data);
    else
        py_cmd = PyObject_CallFunction (type_data->factory_func, (char*) "OO",
                                        py_data, py_flags);

    Py_DECREF (py_data);
    Py_DECREF (py_flags);

    if (!py_cmd)
    {
        PyErr_Print ();
        return NULL;
    }

    if (py_cmd == Py_None)
    {
        Py_DECREF (py_cmd);
        return NULL;
    }

    if (!pygobject_check (py_cmd, &PyMooCommand_Type))
    {
        g_warning ("command must be of type MooCommand");
        Py_DECREF (py_cmd);
        return NULL;
    }

    cmd = g_object_ref (pygobject_get (py_cmd));

    Py_DECREF (py_cmd);
    return cmd;
}

static GtkWidget *
command_create_widget (gpointer user_data)
{
    PyObject *py_widget;
    GtkWidget *widget;
    CommandTypeData *type_data = user_data;

    if (type_data->data)
        py_widget = PyObject_CallFunction (type_data->create_widget_func, (char*) "O", type_data->data);
    else
        py_widget = PyObject_CallFunction (type_data->create_widget_func, (char*) "");

    if (!py_widget)
    {
        PyErr_Print ();
        return NULL;
    }

    if (py_widget == Py_None)
    {
        Py_DECREF (py_widget);
        return NULL;
    }

    if (!pygobject_check (py_widget, &PyGtkWidget_Type))
    {
        g_warning ("return value must be a GtkWidget");
        Py_DECREF (py_widget);
        return NULL;
    }

    widget = g_object_ref (pygobject_get (py_widget));

    Py_DECREF (py_widget);
    return widget;
}

static void
command_load_data (GtkWidget      *widget,
                   MooCommandData *data,
                   gpointer        user_data)
{
    PyObject *py_widget, *py_data;
    CommandTypeData *type_data = user_data;
    PyObject *py_ret;

    py_data = pyg_boxed_new (MOO_TYPE_COMMAND_DATA, data, TRUE, TRUE);
    py_widget = pygobject_new (G_OBJECT (widget));

    if (type_data->data)
        py_ret = PyObject_CallFunction (type_data->load_data_func, (char*) "OOO",
                                        py_widget, py_data, type_data->data);
    else
        py_ret = PyObject_CallFunction (type_data->load_data_func, (char*) "OO",
                                        py_widget, py_data);

    if (!py_ret)
    {
        PyErr_Print ();
    }
    else
    {
        Py_DECREF (py_ret);
    }
}

static gboolean
command_save_data (GtkWidget      *widget,
                   MooCommandData *data,
                   gpointer        user_data)
{
    PyObject *py_widget, *py_data;
    CommandTypeData *type_data = user_data;
    PyObject *py_ret;
    gboolean ret = FALSE;

    py_data = pyg_boxed_new (MOO_TYPE_COMMAND_DATA, data, TRUE, TRUE);
    py_widget = pygobject_new (G_OBJECT (widget));

    if (type_data->data)
        py_ret = PyObject_CallFunction (type_data->save_data_func, (char*) "OOO",
                                        py_widget, py_data, type_data->data);
    else
        py_ret = PyObject_CallFunction (type_data->save_data_func, (char*) "OO",
                                        py_widget, py_data);

    if (!py_ret)
    {
        PyErr_Print ();
    }
    else
    {
        ret = PyObject_IsTrue (py_ret);
        Py_DECREF (py_ret);
    }

    return ret;
}

static void
command_type_data_free (CommandTypeData *data)
{
    if (data)
    {
        Py_XDECREF (data->factory_func);
        Py_XDECREF (data->create_widget_func);
        Py_XDECREF (data->load_data_func);
        Py_XDECREF (data->save_data_func);
        Py_XDECREF (data->data);
        g_free (data);
    }
}

static PyObject *
_wrap_moo_command_type_register (G_GNUC_UNUSED PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {(char*) "id",
                             (char*) "name",
                             (char*) "factory_func",
                             (char*) "create_widget_func",
                             (char*) "load_data_func",
                             (char*) "save_data_func",
                             (char*) "data",
                             NULL};
    char *type, *name;
    PyObject *factory_func, *create_widget_func, *load_data_func, *save_data_func;
    PyObject *factory_data = NULL;
    CommandTypeData *data;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, (char*) "ssOOOO|O:command_type_register",
                                      kwlist, &type, &name,
                                      &factory_func, &factory_data))
        return NULL;

    if (!PyCallable_Check (factory_func))
        return_TypeError ("command_register: factory_func must be callable");
    if (!PyCallable_Check (create_widget_func))
        return_TypeError ("command_register: create_widget_func must be callable");
    if (!PyCallable_Check (load_data_func))
        return_TypeError ("command_register: load_data_func must be callable");
    if (!PyCallable_Check (save_data_func))
        return_TypeError ("command_register: save_data_func must be callable");

    Py_INCREF (factory_func);
    Py_INCREF (create_widget_func);
    Py_INCREF (load_data_func);
    Py_INCREF (save_data_func);
    Py_XINCREF (factory_data);

    data = g_new0 (CommandTypeData, 1);
    data->factory_func = factory_func;
    data->create_widget_func = create_widget_func;
    data->load_data_func = load_data_func;
    data->save_data_func = save_data_func;
    data->data = factory_data;

    moo_command_type_register (type, name,
                               command_factory_func,
                               command_create_widget,
                               command_load_data,
                               command_save_data,
                               data,
                               (GDestroyNotify) command_type_data_free);

    return_None;
}
%%
override moo_command_type_registered kwargs
static PyObject *
_wrap_moo_command_type_registered (G_GNUC_UNUSED PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { (char*) "type", NULL };
    char *type;
    int ret;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,(char*) "s:command_type_registered", kwlist, &type))
        return NULL;

    ret = moo_command_type_lookup (type) != NULL;

    return PyBool_FromLong (ret);
}
