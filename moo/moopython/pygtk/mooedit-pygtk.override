/* kate: lang C; indent-width 4; space-indent on; strip on; */
%%
headers
#include <Python.h>
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include "mooedit/mooeditor.h"
#include "mooedit/mootextsearch.h"
#include "mooedit/mootextbuffer.h"
#include "mooedit/moocmdview.h"
#include "mooedit/mootextiter.h"
#include "mooedit/mooeditprefs.h"
#include "moopython/mooplugin-python.h"
#include "moopython/moopython-utils.h"
#include "moopython/pygtk/moo-pygtk.h"


#ifdef __WIN32__
GType moo_cmd_view_get_type (void)
{
    static int n = 0;
    g_return_val_if_fail (!n++, 0);
    return 0;
}
#endif


%%
modulename _moo_edit
%%
import gtk.Widget as PyGtkWidget_Type
import gtk.TextView as PyGtkTextView_Type
import gtk.TextBuffer as PyGtkTextBuffer_Type
import gtk.TextTagTable as PyGtkTextTagTable_Type
import gtk.TextTag as PyGtkTextTag_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gobject.GObject as PyGObject_Type
import _moo_utils.Window as PyMooWindow_Type
import _moo_utils.UIXML as PyMooUIXML_Type
%%
ignore-glob
  *_get_type
%%
ignore-glob-win32
  MOO_TYPE_CMD_VIEW
  moo_cmd_view*
  MooCmdView
%%
override moo_python_plugin_hook varargs
static PyObject *
_wrap_moo_python_plugin_hook (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *event, *callback;
    PyObject *data = NULL;
    PyObject *result;
    int len;

    len = PyTuple_GET_SIZE (args);

    if (len < 2)
        return_TypeErr ("at least two arguments required");

    event = PyTuple_GET_ITEM (args, 0);

    if (!PyString_Check (event))
        return_TypeErr ("event must be a string");

    callback = PyTuple_GET_ITEM (args, 1);

    if (!PyCallable_Check (callback))
        return_TypeErr ("callback must be a callable");

    if (len > 2)
        data = PyTuple_GetSlice (args, 2, len);

    result = _moo_python_plugin_hook (PyString_AS_STRING (event),
                                      callback, data);
    Py_XDECREF (data);

    return result;
}
%%
override moo_python_plugin_register varargs
static PyObject *
_wrap_moo_python_plugin_register (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *plugin_type, *win_plugin_type = NULL, *doc_plugin_type = NULL;

    if (!PyArg_ParseTuple (args, (char*) "O|OO:plugin_register", &plugin_type,
                           &win_plugin_type, &doc_plugin_type))
        return NULL;

    if (!PyType_Check (plugin_type))
        return_TypeErr ("argument must be a type");

    if (win_plugin_type && win_plugin_type != Py_None && !PyType_Check (win_plugin_type))
        return_TypeErr ("argument must be a type");

    if (doc_plugin_type && doc_plugin_type != Py_None && !PyType_Check (doc_plugin_type))
        return_TypeErr ("argument must be a type");

    if (win_plugin_type == Py_None)
        win_plugin_type = NULL;
    if (doc_plugin_type == Py_None)
        doc_plugin_type = NULL;

    return _moo_python_plugin_register (plugin_type, win_plugin_type, doc_plugin_type);
}
%%
override moo_edit_window_list_docs noargs
static PyObject *
_wrap_moo_edit_window_list_docs (PyObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_edit_window_list_docs (MOO_EDIT_WINDOW (pygobject_get (self)));
    result = moo_object_slist_to_pyobject (list);

    g_slist_free (list);
    return result;
}
%%
override moo_editor_list_windows noargs
static PyObject *
_wrap_moo_editor_list_windows (PyObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_editor_list_windows (MOO_EDITOR (pygobject_get (self)));
    result = moo_object_slist_to_pyobject (list);

    g_slist_free (list);
    return result;
}
%%
override moo_editor_list_docs noargs
static PyObject *
_wrap_moo_editor_list_docs (PyObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_editor_list_docs (MOO_EDITOR (pygobject_get (self)));
    result = moo_object_slist_to_pyobject (list);

    g_slist_free (list);
    return result;
}
%%
override-attr MooLang.mime_types
static PyObject *
_wrap_moo_lang__get_mime_types (PyObject *self, G_GNUC_UNUSED void *closure)
{
    return moo_string_slist_to_pyobject (pyg_boxed_get (self, MooLang)->mime_types);
}
%%
override-attr MooLang.extensions
static PyObject *
_wrap_moo_lang__get_extensions (PyObject *self, G_GNUC_UNUSED void *closure)
{
    return moo_string_slist_to_pyobject (pyg_boxed_get (self, MooLang)->extensions);
}
%%
override moo_line_view_set_line_data varargs
static PyObject *
_wrap_moo_line_view_set_line_data (PyObject *self, PyObject *args)
{
    int line;
    PyObject *py_data;
    MooLineView *view;
    GValue data;

    if (!PyArg_ParseTuple (args, (char*) "iO:LineView.set_line_data", &line, &py_data))
        return NULL;

    view = MOO_LINE_VIEW (pygobject_get (self));

    data.g_type = 0;
    g_value_init (&data, MOO_TYPE_PY_OBJECT);

    if (pyg_value_from_pyobject (&data, py_data))
    {
        g_critical ("%s: oops", G_STRLOC);
        return NULL;
    }

    moo_line_view_set_line_data (view, line, &data);
    g_value_unset (&data);

    return_None;
}
%%
override moo_line_view_get_line_data varargs
static PyObject *
_wrap_moo_line_view_get_line_data (PyObject *self, PyObject *args)
{
    int line;
    MooLineView *view;
    GValue data;
    PyObject *obj;

    if (!PyArg_ParseTuple (args, (char*) "i:LineView.get_line_data", &line))
        return NULL;

    view = MOO_LINE_VIEW (pygobject_get (self));
    data.g_type = 0;

    if (!moo_line_view_get_line_data (view, line, &data))
        return_None;

    obj = pyg_value_as_pyobject (&data, FALSE);

    g_value_unset (&data);
    return obj;
}
%%
override moo_text_search_forward varargs
static PyObject *
_wrap_moo_text_search_forward (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *py_start, *py_flags, *py_end = Py_None;
    char *str;
    int flags;
    const GtkTextIter *start, *end = NULL;
    GtkTextIter match_start, match_end;

    if (!PyArg_ParseTuple(args, (char*) "OsO|O:search_forward", &py_start, &str, &py_flags, &py_end))
        return NULL;

    if (pyg_boxed_check (py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get (py_start, GtkTextIter);
    else
        return_TypeErr ("start should be a GtkTextIter");

    if (pyg_flags_get_value (MOO_TYPE_TEXT_SEARCH_FLAGS, py_flags, &flags))
        return NULL;

    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else if (py_end != Py_None)
        return_TypeErr ("end should be a GtkTextIter or None");

    if (moo_text_search_forward (start, str, flags, &match_start, &match_end, end))
    {
        PyObject *ret = PyTuple_New (2);
        PyTuple_SET_ITEM (ret, 0, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_start, TRUE, TRUE));
        PyTuple_SET_ITEM (ret, 1, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_end, TRUE, TRUE));
        return ret;
    }
    else
    {
        return_None;
    }
}
%%
override moo_text_search_backward varargs
static PyObject *
_wrap_moo_text_search_backward (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *py_start, *py_flags, *py_end = Py_None;
    char *str;
    int flags;
    const GtkTextIter *start, *end = NULL;
    GtkTextIter match_start, match_end;

    if (!PyArg_ParseTuple (args, (char*) "OsO|O:search_backward", &py_start, &str, &py_flags, &py_end))
        return NULL;

    if (pyg_boxed_check (py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get (py_start, GtkTextIter);
    else
        return_TypeErr ("start should be a GtkTextIter");

    if (pyg_flags_get_value (MOO_TYPE_TEXT_SEARCH_FLAGS, py_flags, &flags))
        return NULL;

    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else if (py_end != Py_None)
        return_TypeErr ("end should be a GtkTextIter or None");

    if (moo_text_search_backward (start, str, flags, &match_start, &match_end, end))
    {
        PyObject *ret = PyTuple_New (2);
        PyTuple_SET_ITEM (ret, 0, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_start, TRUE, TRUE));
        PyTuple_SET_ITEM (ret, 1, pyg_boxed_new (GTK_TYPE_TEXT_ITER, &match_end, TRUE, TRUE));
        return ret;
    }
    else
    {
        return_None;
    }
}
