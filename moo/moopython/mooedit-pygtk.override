%%
headers
#include <Python.h>
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include "mooedit/mooeditor.h"
#include "mooedit/mooeditsearch.h"
#include "mooedit/mootextbuffer.h"
#include "mooedit/moocmdview.h"
#include "mooedit/mootextiter.h"
#include "mooedit/mooeditprefs.h"
#include "moopython/mooplugin-python.h"
#include "mooutils/mooutils-python.h"
#include "moopython/moo-pygtk.h"


%%
modulename _moo_edit
%%
import gtk.Widget as PyGtkWidget_Type
import gtk.TextView as PyGtkTextView_Type
import gtk.TextBuffer as PyGtkTextBuffer_Type
import gtk.TextTagTable as PyGtkTextTagTable_Type
import gtk.TextTag as PyGtkTextTag_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gobject.GObject as PyGObject_Type
import _moo_utils.Window as PyMooWindow_Type
import _moo_utils.UIXML as PyMooUIXML_Type
%%
ignore-glob
  *_get_type
%%
override moo_python_plugin_hook varargs
static PyObject *
_wrap_moo_python_plugin_hook (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *event, *callback;
    PyObject *data = NULL;
    PyObject *result;
    int len;

    len = PyTuple_GET_SIZE (args);

    if (len < 2)
        return_TypeErr ("at least two arguments required");

    event = PyTuple_GET_ITEM (args, 0);

    if (!PyString_Check (event))
        return_TypeErr ("event must be a string");

    callback = PyTuple_GET_ITEM (args, 1);

    if (!PyCallable_Check (callback))
        return_TypeErr ("callback must be a callable");

    if (len > 2)
        data = PyTuple_GetSlice (args, 2, len);

    result = _moo_python_plugin_hook (PyString_AS_STRING (event),
                                      callback, data);
    Py_XDECREF (data);

    return result;
}
%%
override moo_python_plugin_register varargs
static PyObject *
_wrap_moo_python_plugin_register (G_GNUC_UNUSED PyObject *self, PyObject *args)
{
    PyObject *plugin_type, *win_plugin_type = NULL, *doc_plugin_type = NULL;

    if (!PyArg_ParseTuple (args, (char*) "O|OO:plugin_register", &plugin_type,
                           &win_plugin_type, &doc_plugin_type))
        return NULL;

    if (!PyType_Check (plugin_type))
        return_TypeErr ("argument must be a type");

    if (win_plugin_type && win_plugin_type != Py_None && !PyType_Check (win_plugin_type))
        return_TypeErr ("argument must be a type");

    if (doc_plugin_type && doc_plugin_type != Py_None && !PyType_Check (doc_plugin_type))
        return_TypeErr ("argument must be a type");

    if (win_plugin_type == Py_None)
        win_plugin_type = NULL;
    if (doc_plugin_type == Py_None)
        doc_plugin_type = NULL;

    return _moo_python_plugin_register (plugin_type, win_plugin_type, doc_plugin_type);
}
%%
override moo_line_view_set_line_data varargs
static void
py_object_unref (PyObject *obj)
{
    Py_XDECREF (obj);
}
static PyObject *
_wrap_moo_line_view_set_line_data (PyObject *self, PyObject *args)
{
    int line;
    PyObject *data;
    MooLineView *view;

    if (!PyArg_ParseTuple (args, (char*) "iO:LineView.set_line_data", &line, &data))
        return NULL;

    view = MOO_LINE_VIEW (pygobject_get (self));
    moo_line_view_set_line_data (view, line, data, (GDestroyNotify) py_object_unref);

    return_None;
}
%%
override moo_line_view_get_line_data varargs
static PyObject *
_wrap_moo_line_view_get_line_data (PyObject *self, PyObject *args)
{
    int line;
    PyObject *data;
    MooLineView *view;

    if (!PyArg_ParseTuple (args, (char*) "i:LineView.get_line_data", &line))
        return NULL;

    view = MOO_LINE_VIEW (pygobject_get (self));
    data = moo_line_view_get_line_data (view, line);

    if (!data)
        data = Py_None;

    Py_INCREF (data);
    return data;
}
%%
override moo_edit_window_list_docs noargs
static PyObject *
_wrap_moo_edit_window_list_docs (PyObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_edit_window_list_docs (MOO_EDIT_WINDOW (pygobject_get (self)));
    result = moo_object_slist_to_pyobject (list);

    g_slist_free (list);
    return result;
}
%%
override moo_editor_list_windows noargs
static PyObject *
_wrap_moo_editor_list_windows (PyObject *self)
{
    GSList *list;
    PyObject *result;

    list = moo_editor_list_windows (MOO_EDITOR (pygobject_get (self)));
    result = moo_object_slist_to_pyobject (list);

    g_slist_free (list);
    return result;
}
%%
override-attr MooLang.mime_types
static PyObject *
_wrap_moo_lang__get_mime_types (PyObject *self, G_GNUC_UNUSED void *closure)
{
    return moo_string_slist_to_pyobject (pyg_boxed_get (self, MooLang)->mime_types);
}
%%
override-attr MooLang.extensions
static PyObject *
_wrap_moo_lang__get_extensions (PyObject *self, G_GNUC_UNUSED void *closure)
{
    return moo_string_slist_to_pyobject (pyg_boxed_get (self, MooLang)->extensions);
}
