/*
 *   medit-app.c
 *
 *   Copyright (C) 2004-2006 by Yevgen Muntyan <muntyan@math.tamu.edu>
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   See COPYING file that comes with this distribution.
 */

#include "medit-credits.h"
#include <moo.h>
#include <mooutils/mooutils-win32.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#if GTK_CHECK_VERSION(2,8,0) && defined(GDK_WINDOWING_X11)
#include <gdk/gdkx.h>
#define TIMESTAMP() (gdk_x11_display_get_user_time (gdk_display_get_default ()))
#else
#define TIMESTAMP() (0)
#endif


#if 1
static void
init_mem_stuff (void)
{
}
#else
#define ALIGN 4
#include <libxml/xmlmemory.h>

static gpointer
my_malloc (gsize n_bytes)
{
    char *mem = malloc (n_bytes + ALIGN);
    return mem ? mem + ALIGN : NULL;
}

static gpointer
my_realloc (gpointer mem,
	    gsize    n_bytes)
{
    if (mem)
    {
        char *new_mem = realloc ((char*) mem - ALIGN, n_bytes + ALIGN);
        return new_mem ? new_mem + ALIGN : NULL;
    }
    else
    {
        return my_malloc (n_bytes);
    }
}

static char *
my_strdup (const char *s)
{
    if (s)
    {
        char *new_s = my_malloc (strlen (s) + 1);
        strcpy (new_s, s);
        return new_s;
    }
    else
    {
        return NULL;
    }
}

static void
my_free (gpointer mem)
{
    if (mem)
        free ((char*) mem - ALIGN);
}

static void
init_mem_stuff (void)
{
    GMemVTable mem_table = {
        my_malloc,
        my_realloc,
        my_free,
        NULL, NULL, NULL
    };

    if (0)
    {
        g_mem_set_vtable (&mem_table);
        g_slice_set_config (G_SLICE_CONFIG_ALWAYS_MALLOC, TRUE);
    }
    else
    {
        xmlMemSetup (my_free, my_malloc, my_realloc, my_strdup);
    }
}
#endif


typedef enum {
    MODE_SIMPLE,
    MODE_PROJECT
} AppMode;


int _medit_parse_options (const char *const program_name,
                          const int         argc,
                          char **const      argv);

/********************************************************
 * command line parsing code generated by Opag
 * http://www.zero-based.org/software/opag/
 */
%%
n  new-app      "Run new instance of application"
   pid          "=PID Use existing instance with process id PID"    reqarg
m  mode         "=[simple|project] Use specified mode"              reqarg
p  project      "=PROJECT Open project file PROJECT"                reqarg
l  line         "=LINE Open file and position cursor on line LINE"  reqarg
   log          "[=FILE] Show debug output or write it to FILE"     optarg
   debug        "Run in debug mode"
   version      "Display version information and exit"              return
h  help         "Display this help text and exit"                   return
%%
/* end of generated code
 ********************************************************/


static void
usage (void)
{
    g_print ("Usage: %s [OPTIONS] [FILES]\n", g_get_prgname ());
    g_print ("Options:\n%s", STR_HELP);
}

static void
version (void)
{
    g_print ("medit %s\n", MOO_VERSION);
}


static void
check_args (int opt_remain)
{
    if (_medit_opt_help)
    {
        usage ();
        exit (0);
    }

    if (opt_remain < 0)
    {
        usage ();
        exit (1);
    }

    if (_medit_opt_pid)
    {
        if (_medit_opt_mode)
        {
            g_print ("--mode can't be used together with --pid\n");
            exit (1);
        }

        if (_medit_opt_project)
        {
            g_print ("--project can't be used together with --pid\n");
            exit (1);
        }

        if (_medit_opt_new_app)
        {
            g_print ("--new-app can't be used together with --pid\n");
            exit (1);
        }

        if (!_medit_arg_pid || !_medit_arg_pid[0])
        {
            usage ();
            exit (1);
        }
    }

    if (_medit_opt_mode)
    {
        if (!_medit_arg_mode ||
            (strcmp (_medit_arg_mode, "simple") &&
             strcmp (_medit_arg_mode, "project")))
        {
            usage ();
            exit (1);
        }
    }

    if (_medit_opt_project && _medit_arg_mode &&
        strcmp (_medit_arg_mode, "project"))
    {
        usage ();
        exit (1);
    }

    if (_medit_opt_version)
    {
        version ();
        exit (0);
    }
}


static void
push_appdir_to_path (void)
{
#ifdef __WIN32__
    char *appdir;
    const char *path;
    char *new_path;

    appdir = moo_win32_get_app_dir ();
    g_return_if_fail (appdir != NULL);

    path = g_getenv ("Path");

    if (path)
        new_path = g_strdup_printf ("%s;%s", appdir, path);
    else
        new_path = g_strdup (appdir);

    g_setenv ("Path", new_path, TRUE);

    g_free (new_path);
    g_free (appdir);
#endif
}


int
main (int argc, char *argv[])
{
    MooApp *app;
    int opt_remain;
    MooEditor *editor;
    char **files;
    gpointer window;
    int retval;
    gboolean new_instance = FALSE;
    gboolean run_input = TRUE;
    AppMode mode = MODE_SIMPLE;
    guint32 stamp;
    guint32 line = 0;
    const char *pid_string = NULL;

    init_mem_stuff ();

    /* Tim Janik said */
    g_thread_init (NULL);
    gdk_threads_init ();

    gtk_init (&argc, &argv);
    stamp = TIMESTAMP ();

#if 0
    gdk_window_set_debug_updates (TRUE);
#endif

    opt_remain = _medit_parse_options (g_get_prgname (), argc, argv);
    check_args (opt_remain);

    if (_medit_opt_debug)
        g_setenv ("MOO_DEBUG", "yes", FALSE);

    if (_medit_opt_log)
    {
        if (_medit_arg_log)
            moo_set_log_func_file (_medit_arg_log);
        else
            moo_set_log_func_window (TRUE);
    }

    push_appdir_to_path ();

    if (_medit_opt_mode)
    {
        if (!strcmp (_medit_arg_mode, "simple"))
            mode = MODE_SIMPLE;
        else
            mode = MODE_PROJECT;
    }

    if (_medit_opt_project)
        mode = MODE_PROJECT;

    if (_medit_opt_new_app || mode == MODE_PROJECT)
        new_instance = TRUE;

    files = moo_filenames_from_locale (argv + opt_remain);

    app = g_object_new (MOO_TYPE_APP,
                        "argv", argv,
                        "run-input", run_input,
                        "short-name", "medit",
                        "full-name", "medit",
                        "description", "medit is a text editor",
                        "website", "http://mooedit.sourceforge.net/",
                        "website-label", "http://mooedit.sourceforge.net/",
                        "logo", MOO_STOCK_MEDIT,
                        "credits", THANKS,
                        NULL);

    if (_medit_arg_line)
        line = strtol (_medit_arg_line, NULL, 10);

    if (_medit_opt_pid)
        pid_string = _medit_arg_pid;
    else if (!_medit_opt_new_app)
        pid_string = g_getenv ("MEDIT_PID");

    if (pid_string)
    {
        if (moo_app_send_files (app, files, line, stamp, pid_string))
        {
            exit (0);
        }
        else
        {
            g_print ("Could not send files to pid %s\n", pid_string);
            exit (1);
        }
    }

    if ((!new_instance && moo_app_send_files (app, files, line, stamp, NULL)) ||
         !moo_app_init (app))
    {
        gdk_notify_startup_complete ();
        g_strfreev (files);
        g_object_unref (app);
        return 0;
    }

    if (mode == MODE_PROJECT)
    {
        MooPlugin *plugin;

        plugin = moo_plugin_lookup ("ProjectManager");

        if (!plugin)
        {
            g_printerr ("Could not initialize project manager plugin\n");
            exit (1);
        }

        if (_medit_arg_project && *_medit_arg_project)
        {
            char *project = moo_filename_from_locale (_medit_arg_project);
            g_object_set (plugin, "project", _medit_arg_project, NULL);
            g_free (project);
        }

        moo_plugin_set_enabled (plugin, TRUE);
    }

    editor = moo_app_get_editor (app);
    window = moo_editor_new_window (editor);

    if (files && *files)
    {
        char **p;

        for (p = files; p && *p; ++p)
        {
            if (p == files && line > 0)
                moo_editor_open_file_line (editor, *p, line - 1, window);
            else
                moo_editor_new_file (editor, window, NULL, *p, NULL);
        }
    }

    g_strfreev (files);

    g_signal_connect_swapped (editor, "all-windows-closed",
                              G_CALLBACK (moo_app_quit), app);

    gdk_threads_enter ();
    retval = moo_app_run (app);
    gdk_threads_leave ();

    g_object_unref (app);
    return retval;
}


#if defined(__WIN32__) && !defined(__GNUC__)

#include <windows.h>

int __stdcall
WinMain (HINSTANCE hInstance,
	     HINSTANCE hPrevInstance,
		 char     *lpszCmdLine,
		 int       nCmdShow)
{
	return main (__argc, __argv);
}

#endif
